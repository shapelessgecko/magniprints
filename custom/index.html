<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Print - MagniPrints</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
    <link rel="stylesheet" href="../css/styles.css">
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar">
        <div class="logo">MagniPrints</div>
        <ul class="nav-links">
            <li><a href="../index.html">Home</a></li>
            <li><a href="../products/">Products</a></li>
            <li><a href="./">Custom Print</a></li>
            <li><a href="../track/">Track Order</a></li>
        </ul>
        <div class="nav-controls">
            <button class="theme-toggle" id="themeToggle" aria-label="Toggle theme">
                <span id="themeIcon">‚òÄÔ∏è</span>
            </button>
            <button class="mobile-menu-btn" id="mobileMenuBtn">‚ò∞</button>
        </div>
    </nav>

    <section class="upload-section">
        <div class="upload-header reveal">
            <h1 class="section-title">Upload Your Design</h1>
            <p class="section-subtitle">Drop your STL file or try our sample models</p>
        </div>

        <!-- File Upload Zone -->
        <div class="upload-zone reveal" id="uploadZone">
            <span style="font-size: 4rem;">üìÅ</span>
            <h3>Drop your STL file here</h3>
            <p>or click to browse (max 50MB)</p>
            <input type="file" class="upload-input" id="fileInput" accept=".stl">
        </div>

        <!-- Sample Models -->
        <div class="sample-models reveal">
            <h3>Try Sample Models</h3>
            <div class="sample-grid">
                <div class="sample-card" onclick="loadSample('phone-stand')">
                    <span>üì±</span>
                    <span>Phone Stand</span>
                </div>
                <div class="sample-card" onclick="loadSample('vase')">
                    <span>üè∫</span>
                    <span>Decorative Vase</span>
                </div>
                <div class="sample-card" onclick="loadSample('figurine')">
                    <span>üé≠</span>
                    <span>Abstract Figurine</span>
                </div>
            </div>
        </div>

        <!-- 3D Viewer and Settings -->
        <div class="viewer-section">
            <!-- 3D Viewer -->
            <div class="viewer-container reveal" id="viewerContainer">
                <div class="loader-container" id="loader">
                    <div class="spinner"></div>
                </div>
            </div>

            <!-- Settings Panel -->
            <div class="settings-panel reveal">
                <h3>Print Settings</h3>
                
                <!-- Layer Height -->
                <div class="setting-row">
                    <label>Layer Height</label>
                    <input type="range" id="layerHeight" min="0.1" max="0.3" step="0.05" value="0.2">
                    <span class="setting-value" id="layerHeightValue">0.2mm (Standard)</span>
                </div>

                <!-- Infill -->
                <div class="setting-row">
                    <label>Infill Percentage</label>
                    <input type="range" id="infill" min="10" max="100" step="5" value="20">
                    <span class="setting-value" id="infillValue">20%</span>
                </div>

                <!-- Wall Thickness -->
                <div class="setting-row">
                    <label>Wall Thickness</label>
                    <input type="range" id="wallThickness" min="0.8" max="2.0" step="0.2" value="1.2">
                    <span class="setting-value" id="wallThicknessValue">1.2mm</span>
                </div>

                <!-- Material Selector -->
                <div class="setting-row">
                    <label style="margin-bottom: 0.75rem;">Material</label>
                    <div class="filament-colors" style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                        <div class="filament-color active" data-material="pla" data-price="2.5" style="background: #ffffff;" title="PLA ‚Çπ2.5/g"></div>
                        <div class="filament-color" data-material="petg" data-price="3.5" style="background: #3b82f6;" title="PETG ‚Çπ3.5/g"></div>
                        <div class="filament-color" data-material="abs" data-price="4.0" style="background: #ef4444;" title="ABS ‚Çπ4.0/g"></div>
                        <div class="filament-color" data-material="tpu" data-price="5.5" style="background: #22c55e;" title="TPU ‚Çπ5.5/g"></div>
                        <div class="filament-color" data-material="wood" data-price="6.0" style="background: #92400e;" title="Wood ‚Çπ6.0/g"></div>
                        <div class="filament-color" data-material="nylon" data-price="7.5" style="background: #f97316;" title="Nylon ‚Çπ7.5/g"></div>
                    </div>
                    <p style="margin-top: 0.5rem; font-size: 0.85rem; opacity: 0.8;">
                        <span id="selectedMaterial">PLA White</span>
                    </p>
                </div>

                <!-- Print Statistics -->
                <div style="margin-top: 2rem; padding: 1.5rem; background: var(--bg); border-radius: 12px;">
                    <h4 style="font-size: 0.85rem; text-transform: uppercase; margin-bottom: 1rem; opacity: 0.7;">Print Statistics</h4>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">
                        <div>
                            <span style="font-size: 0.8rem; opacity: 0.6;">Dimensions</span>
                            <p id="modelDimensions" style="font-weight: 600;">--</p>
                        </div>
                        <div>
                            <span style="font-size: 0.8rem; opacity: 0.6;">Volume</span>
                            <p id="modelVolume" style="font-weight: 600;">--</p>
                        </div>
                        <div>
                            <span style="font-size: 0.8rem; opacity: 0.6;">Est. Weight</span>
                            <p id="modelWeight" style="font-weight: 600;">--</p>
                        </div>
                        <div>
                            <span style="font-size: 0.8rem; opacity: 0.6;">Print Time</span>
                            <p id="printTime" style="font-weight: 600;">--</p>
                        </div>
                    </div>
                </div>

                <!-- Cost Display -->
                <div class="cost-display">
                    <h4>Estimated Cost</h4>
                    <div class="cost-price">‚Çπ<span id="totalCost">0</span></div>
                    <p style="font-size: 0.9rem; opacity: 0.8; margin-top: 0.5rem;">Material + Setup Fee (‚Çπ50)</p>
                </div>

                <!-- Order Buttons -->
                <button class="whatsapp-btn" onclick="orderViaWhatsApp()">
                    <span>üì±</span>
                    <span>Order via WhatsApp</span>
                </button>
                
                <button class="viewer-btn" style="width: 100%; margin-top: 0.75rem; padding: 1rem;" onclick="resetViewer()">
                    <span>üóëÔ∏è Clear Model</span>
                </button>
            </div>
        </div>
    </section>

    <script>
        // Theme Toggle
        const themeToggle = document.getElementById('themeToggle');
        const html = document.documentElement;
        themeToggle.addEventListener('click', () => {
            const current = html.getAttribute('data-theme');
            const next = current === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', next);
            document.getElementById('themeIcon').textContent = next === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        });

        // Mobile Menu
        document.getElementById('mobileMenuBtn').addEventListener('click', () => {
            document.querySelector('.nav-links').classList.toggle('active');
        });

        // Three.js Setup
        let scene, camera, renderer, controls, currentMesh;
        let modelVolume = 0;
        let modelWeight = 0;

        function initViewer() {
            const container = document.getElementById('viewerContainer');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(getComputedStyle(document.body).getPropertyValue('--card').trim() || 0x0a0a0a);
            
            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 5);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            const spotLight = new THREE.SpotLight(0x667eea, 0.5);
            spotLight.position.set(-5, 5, 0);
            scene.add(spotLight);

            // Grid helper
            const gridHelper = new THREE.GridHelper(10, 10, 0x667eea, 0x2a2a2a);
            gridHelper.position.y = -1.5;
            scene.add(gridHelper);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        initViewer();

        // Materials Map
        const materials = {
            'pla': { color: 0xffffff, roughness: 0.8, metalness: 0.1, density: 1.24, name: 'PLA White' },
            'petg': { color: 0x3b82f6, roughness: 0.6, metalness: 0.2, density: 1.27, name: 'PETG' },
            'abs': { color: 0xef4444, roughness: 0.7, metalness: 0.1, density: 1.04, name: 'ABS' },
            'tpu': { color: 0x22c55e, roughness: 0.9, metalness: 0, density: 1.21, name: 'TPU' },
            'wood': { color: 0x92400e, roughness: 0.9, metalness: 0, density: 1.4, name: 'Wood' },
            'nylon': { color: 0xf97316, roughness: 0.6, metalness: 0.1, density: 1.14, name: 'Nylon' }
        };

        let currentMaterial = materials['pla'];

        // Sample Generators
        const sampleGenerators = {
            'phone-stand': () => {
                const group = new THREE.Group();
                
                const base = new THREE.Mesh(
                    new THREE.BoxGeometry(2.5, 0.25, 1.5),
                    new THREE.MeshStandardMaterial(currentMaterial)
                );
                base.position.y = 0.125;
                base.castShadow = true;
                group.add(base);
                
                const support = new THREE.Mesh(
                    new THREE.BoxGeometry(2.5, 1.2, 0.1),
                    new THREE.MeshStandardMaterial(currentMaterial)
                );
                support.position.set(0, 0.8, 0.6);
                support.rotation.x = -0.25;
                support.castShadow = true;
                group.add(support);
                
                const lip = new THREE.Mesh(
                    new THREE.BoxGeometry(2.5, 0.08, 0.15),
                    new THREE.MeshStandardMaterial(currentMaterial)
                );
                lip.position.set(0, 1.35, 0.3);
                lip.castShadow = true;
                group.add(lip);
                
                return group;
            },

            'vase': () => {
                const points = [];
                for (let i = 0; i < 10; i++) {
                    points.push(new THREE.Vector2(
                        0.5 + Math.sin(i * 0.5) * 0.3 + i * 0.05,
                        i * 0.3
                    ));
                }
                
                const geom = new THREE.LatheGeometry(points, 32);
                const material = new THREE.MeshStandardMaterial({
                    ...currentMaterial,
                    side: THREE.DoubleSide
                });
                
                const vase = new THREE.Mesh(geom, material);
                vase.castShadow = true;
                return vase;
            },

            'figurine': () => {
                const group = new THREE.Group();
                
                // Body
                const body = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.4, 1, 4, 16),
                    new THREE.MeshStandardMaterial(currentMaterial)
                );
                body.position.y = 0.9;
                body.castShadow = true;
                group.add(body);
                
                // Head
                const head = new THREE.Mesh(
                    new THREE.SphereGeometry(0.35, 32, 32),
                    new THREE.MeshStandardMaterial(currentMaterial)
                );
                head.position.y = 1.7;
                head.castShadow = true;
                group.add(head);
                
                // Base
                const base = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.8, 0.9, 0.2, 32),
                    new THREE.MeshStandardMaterial(currentMaterial)
                );
                base.position.y = 0.1;
                base.receiveShadow = true;
                group.add(base);
                
                return group;
            }
        };

        // Load Sample Model
        function loadSample(sampleName) {
            showLoader();
            
            setTimeout(() => {
                if (currentMesh) scene.remove(currentMesh);
                
                currentMesh = sampleGenerators[sampleName]();
                
                // Center and scale
                const box = new THREE.Box3().setFromObject(currentMesh);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 2.5 / maxDim;
                
                currentMesh.scale.setScalar(scale);
                currentMesh.position.sub(center.multiplyScalar(scale));
                currentMesh.position.y += 0.5;
                
                scene.add(currentMesh);
                
                // Calculate stats
                calculateStats(currentMesh, size);
                
                hideLoader();
                calculateCost();
            }, 500);
        }

        // STL File Upload
        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');
        const loader = new THREE.STLLoader();

        uploadZone.addEventListener('click', () => fileInput.click());
        
        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });

        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('dragover');
        });

        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        function handleFile(file) {
            if (!file.name.endsWith('.stl')) {
                alert('Please upload an STL file');
                return;
            }

            if (file.size > 50 * 1024 * 1024) {
                alert('File too large. Maximum size is 50MB.');
                return;
            }

            showLoader();

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const geometry = loader.parse(e.target.result);
                    
                    if (currentMesh) scene.remove(currentMesh);
                    
                    const material = new THREE.MeshStandardMaterial(currentMaterial);
                    currentMesh = new THREE.Mesh(geometry, material);
                    currentMesh.castShadow = true;
                    
                    // Center and scale
                    geometry.computeBoundingBox();
                    const center = geometry.boundingBox.getCenter(new THREE.Vector3());
                    const size = new THREE.Vector3();
                    geometry.boundingBox.getSize(size);
                    
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 2.5 / maxDim;
                    
                    currentMesh.scale.setScalar(scale);
                    currentMesh.position.sub(center.multiplyScalar(scale));
                    currentMesh.position.y += 0.5;
                    
                    scene.add(currentMesh);
                    
                    calculateStats(currentMesh, size);
                    hideLoader();
                    calculateCost();
                    
                } catch (error) {
                    alert('Error loading STL file: ' + error.message);
                    hideLoader();
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function showLoader() {
            document.getElementById('loader').style.display = 'flex';
        }

        function hideLoader() {
            document.getElementById('loader').style.display = 'none';
        }

        function calculateStats(mesh, originalSize) {
            // Get actual scaled size
            const scale = mesh.scale.x;
            const width = (originalSize.x * scale * 10).toFixed(1);
            const height = (originalSize.y * scale * 10).toFixed(1);
            const depth = (originalSize.z * scale * 10).toFixed(1);
            
            document.getElementById('modelDimensions').textContent = `${width} √ó ${height} √ó ${depth} mm`;
            
            // Calculate volume (rough approximation for solid model)
            const volumeCm3 = (width * height * depth) / 1000;
            const infill = parseInt(document.getElementById('infill').value) / 100;
            const shellVolume = volumeCm3 * 0.1; // 10% for shells
            modelVolume = shellVolume + (volumeCm3 * infill * 0.9);
            
            document.getElementById('modelVolume').textContent = modelVolume.toFixed(2) + ' cm¬≥';
            
            // Weight calculation
            modelWeight = modelVolume * currentMaterial.density;
            document.getElementById('modelWeight').textContent = modelWeight.toFixed(1) + ' g';
            
            // Print time estimation
            const layerHeight = parseFloat(document.getElementById('layerHeight').value);
            const layerCount = height / (layerHeight * 10);
            const timeHours = Math.max(0.5, (layerCount * modelVolume) / 50).toFixed(1);
            document.getElementById('printTime').textContent = timeHours + ' hours';
        }

        // Setting Controls
        const layerHeightInput = document.getElementById('layerHeight');
        const infillInput = document.getElementById('infill');
        const wallThicknessInput = document.getElementById('wallThickness');

        layerHeightInput.addEventListener('input', () => {
            const val = layerHeightInput.value;
            const label = val <= 0.15 ? 'Fine' : val <= 0.2 ? 'Standard' : val <= 0.25 ? 'Draft' : 'Fast';
            document.getElementById('layerHeightValue').textContent = `${val}mm (${label})`;
            calculateCost();
        });

        infillInput.addEventListener('input', () => {
            const val = infillInput.value;
            document.getElementById('infillValue').textContent = `${val}%`;
            if (currentMesh) {
                const box = new THREE.Box3().setFromObject(currentMesh);
                const size = new THREE.Vector3();
                box.getSize(size);
                size.divideScalar(currentMesh.scale.x);
                calculateStats(currentMesh, size);
            }
            calculateCost();
        });

        wallThicknessInput.addEventListener('input', () => {
            const val = wallThicknessInput.value;
            document.getElementById('wallThicknessValue').textContent = `${val}mm`;
            calculateCost();
        });

        // Material Selector
        const filamentColors = document.querySelectorAll('.filament-color');
        filamentColors.forEach(color => {
            color.addEventListener('click', () => {
                filamentColors.forEach(c => c.classList.remove('active'));
                color.classList.add('active');
                
                const material = color.dataset.material;
                currentMaterial = materials[material];
                document.getElementById('selectedMaterial').textContent = currentMaterial.name;
                
                // Update mesh material
                if (currentMesh) {
                    currentMesh.traverse((child) => {
                        if (child.isMesh) {
                            child.material = new THREE.MeshStandardMaterial(currentMaterial);
                        }
                    });
                    
                    // Recalculate weight
                    const box = new THREE.Box3().setFromObject(currentMesh);
                    const size = new THREE.Vector3();
                    box.getSize(size);
                    size.divideScalar(currentMesh.scale.x);
                    calculateStats(currentMesh, size);
                }
                
                calculateCost();
            });
        });

        // Cost Calculator
        function calculateCost() {
            if (!currentMesh) {
                document.getElementById('totalCost').textContent = '0';
                return;
            }
            
            const pricePerGram = parseFloat(document.querySelector('.filament-color.active')?.dataset.price || 2.5);
            const materialCost = modelWeight * pricePerGram;
            const setupFee = 50;
            const layerMultiplier = parseFloat(layerHeightInput.value) <= 0.15 ? 1.2 : 1;
            
            const total = Math.round((materialCost + setupFee) * layerMultiplier);
            document.getElementById('totalCost').textContent = total;
        }

        // WhatsApp Order
        function orderViaWhatsApp() {
            if (!currentMesh) {
                alert('Please upload or select a model first!');
                return;
            }
            
            const dimensions = document.getElementById('modelDimensions').textContent;
            const volume = document.getElementById('modelVolume').textContent;
            const weight = document.getElementById('modelWeight').textContent;
            const time = document.getElementById('printTime').textContent;
            const total = document.getElementById('totalCost').textContent;
            const material = document.getElementById('selectedMaterial').textContent;
            
            const layerHeight = layerHeightInput.value;
            const infill = infillInput.value;
            
            const message = `Hi MagniPrints! I'd like to order a custom print:\n\nüì¶ Model: Custom STL\nüìê ${dimensions}\n‚öñÔ∏è ${weight} (${volume})\n‚è±Ô∏è Est. Time: ${time}\n\nüîß Settings:\n‚Ä¢ Material: ${material}\n‚Ä¢ Layer Height: ${layerHeight}mm\n‚Ä¢ Infill: ${infill}%\n\nüí∞ Estimated Cost: ‚Çπ${total}\n\nPlease confirm and I'll share the STL file.`;
            
            window.open(`https://wa.me/?text=${encodeURIComponent(message)}`, '_blank');
        }

        function resetViewer() {
            if (currentMesh) {
                scene.remove(currentMesh);
                currentMesh = null;
            }
            
            document.getElementById('modelDimensions').textContent = '--';
            document.getElementById('modelVolume').textContent = '--';
            document.getElementById('modelWeight').textContent = '--';
            document.getElementById('printTime').textContent = '--';
            document.getElementById('totalCost').textContent = '0';
        }

        // Resize handler
        window.addEventListener('resize', () => {
            if (renderer && camera) {
                const container = document.getElementById('viewerContainer');
                renderer.setSize(container.clientWidth, container.clientHeight);
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
            }
        });

        // Scroll reveal
        const reveals = document.querySelectorAll('.reveal');
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('active');
                }
            });
        });
        reveals.forEach(el => observer.observe(el));
    </script>
</body>
</html>
